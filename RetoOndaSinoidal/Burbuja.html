<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Burbuja — onda y rebote exacto</title>
  <style>
    html,body{
      height:100%; margin:0;
      display:flex; align-items:center; justify-content:center;
      background:#b4e5ff;
    }
    canvas{
      display:block;
      border-radius:8px;
      background: #bfe8ff;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script>
  const BG_SRC = 'Background Floor.png';
  const BUB_SRC = 'Burbuja.png';

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // Ajuste de canvas para DPR (nitidez en pantallas retina)
  function resizeCanvasToDisplaySize() {
    const dpr = window.devicePixelRatio || 1;
    const width = Math.min(window.innerWidth - 80, 1100);
    const height = Math.round(width * 0.55);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.width  = Math.round(width * dpr);
    canvas.height = Math.round(height * dpr);
    // Mantener transform para dibujar en coordenadas CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  const bgImg = new Image();
  const bubImg = new Image();
  let imagesLoaded = 0;
  function onImageLoaded(){
    imagesLoaded++;
    if(imagesLoaded === 2) init();
  }
  bgImg.onload = onImageLoaded;
  bubImg.onload = onImageLoaded;
  bgImg.src = BG_SRC;
  bubImg.src = BUB_SRC;

  // Parámetros configurables (fijos en este archivo)
  const SPEED_PX_PER_SEC = 220;   // velocidad horizontal (px/segundo)
  const AMPLITUDE = 70;          // amplitud de la onda (px)
  const SPATIAL_FREQ = 0.015;    // frecuencia espacial (mult. por x)
  const PHASE_SPEED = 2.0;       // velocidad de fase en rad/s (mantiene la onda viva con el tiempo)

  // Estado
  let x;               // posición X (centro, en px CSS)
  let vx;              // velocidad en px/segundo (signo indica dirección)
  let bubbleW, bubbleH;
  let baseY;           // centro vertical base donde oscilar
  let accumulatedTime = 0; // tiempo acumulado en segundos (para fase temporal)
  let lastTs = null;


  function init(){
    resizeCanvasToDisplaySize();


    const canvasW = canvas.width / (window.devicePixelRatio || 1);
    bubbleW = Math.max(100, canvasW / 4); 
    bubbleH = bubbleW;


    x = bubbleW / 2;
    vx = SPEED_PX_PER_SEC; 

    const canvasH = canvas.height / (window.devicePixelRatio || 1);
    baseY = canvasH * 0.55; 


    window.addEventListener('resize', () => {
      resizeCanvasToDisplaySize();
      const newCanvasW = canvas.width / (window.devicePixelRatio || 1);
      bubbleW = Math.max(100, newCanvasW / 4);
      bubbleH = bubbleW;

      const newCanvasH = canvas.height / (window.devicePixelRatio || 1);
      baseY = newCanvasH * 0.55;
 
      clampAndCorrectPosition();
    });

    requestAnimationFrame(loop);
  }


  function clampAndCorrectPosition(){
    const canvasW = canvas.width / (window.devicePixelRatio || 1);
    const leftLimit = bubbleW / 2;
    const rightLimit = canvasW - bubbleW / 2;
    if (x < leftLimit) {
      x = leftLimit;
      vx = Math.abs(vx);
    } else if (x > rightLimit) {
      x = rightLimit;
      vx = -Math.abs(vx);
    }
  }


  function loop(ts){
    if (lastTs === null) lastTs = ts;
    const deltaMs = ts - lastTs;
    lastTs = ts;
    const dt = Math.min(deltaMs / 1000, 0.05);


    accumulatedTime += dt;
    x += vx * dt;


    const canvasW = canvas.width / (window.devicePixelRatio || 1);
    const leftLimit = bubbleW / 2;
    const rightLimit = canvasW - bubbleW / 2;


    if (x > rightLimit) {
      x = rightLimit;                  
      vx = -Math.abs(vx);              
    } else if (x < leftLimit) {
      x = leftLimit;
      vx = Math.abs(vx);
    }


    const phase = accumulatedTime * PHASE_SPEED;
    const sinY = Math.sin(x * SPATIAL_FREQ + phase);
    const drawY = baseY + sinY * AMPLITUDE;


    ctx.clearRect(0,0,canvas.width,canvas.height);
    const canvasH = canvas.height / (window.devicePixelRatio || 1);

    ctx.fillStyle = '#bfe8ff';
    ctx.fillRect(0,0,canvasW,canvasH);

    // Dibujar suelo/background floor alineado abajo, escalado al ancho
    const bgAspect = bgImg.width / bgImg.height;
    const drawBgW = canvasW;
    const drawBgH = drawBgW / bgAspect;
    const bgY = canvasH - drawBgH;
    ctx.drawImage(bgImg, 0, bgY, drawBgW, drawBgH);

    const bx = x - bubbleW / 2;
    const by = drawY - bubbleH / 2;
    ctx.drawImage(bubImg, bx, by, bubbleW, bubbleH);

    requestAnimationFrame(loop);
  }
  </script>
</body>
</html>
